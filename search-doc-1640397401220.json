[{"title":"WrapperService","type":0,"sectionRef":"#","url":"api/WrapperService","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"WrapperService","url":"api/WrapperService#functions","content":" "},{"title":"isWrapped​","type":1,"pageTitle":"WrapperService","url":"api/WrapperService#isWrapped","content":"&lt;/&gt; WrapperService.isWrapped(instanceToCheck: Instance | WrappedInstance) → boolean Returns true if the passed instance is wrapped, false if it's not. local boolean = WrapperService.isWrapped(WrapperService:new(workspace)) -- True   "},{"title":"new​","type":1,"pageTitle":"WrapperService","url":"api/WrapperService#new","content":"&lt;/&gt; WrapperService:new(instanceToWrap: Instance ) → WrappedInstance Creates a wrapped instance. ---@type WrappedInstance | Workspace -- This is for IntelliSense local workspace = WrapperService:new(workspace)   "},{"title":"GetWrappedInstance​","type":1,"pageTitle":"WrapperService","url":"api/WrapperService#GetWrappedInstance","content":"&lt;/&gt; WrapperService:GetWrappedInstance(instanceToGet: Instance ) → WrappedInstance Gets a wrapped version of the instance, returns nil if it doesn't exist. WrapperService:new(workspace) ---@type WrappedInstance | Workspace -- This is for IntelliSense local workspace = WrapperService:GetWrappedInstance(workspace)  "},{"title":"WrappedInstance","type":0,"sectionRef":"#","url":"api/WrappedInstance","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"WrappedInstance","url":"api/WrappedInstance#functions","content":" "},{"title":"Cleanup​","type":1,"pageTitle":"WrappedInstance","url":"api/WrappedInstance#Cleanup","content":"&lt;/&gt; WrappedInstance:Cleanup() → Instance  Destroys/Cleans the wrapped instance for GC Returns the unwrapped version of the wrapped instance ---@type WrappedInstance | Workspace local workspace = WrapperService:new(workspace) local normalWorkspace: Workspace = workspace:Cleanup()   "},{"title":"Add​","type":1,"pageTitle":"WrappedInstance","url":"api/WrappedInstance#Add","content":"&lt;/&gt; WrappedInstance:Add(properties: table&lt;string,table&lt;string,any&gt;&gt;) → () Adds properties to the instance (Event/Method/Property) ---@type WrappedInstance | Workspace -- This is for IntelliSense local workspace = WrapperService:new(workspace) workspace:Add({ NewProperty = { Property = &quot;This is a new property!&quot; }, NewMethod = { Method = function() return workspace:WaitForProperty(&quot;NewProperty&quot;) end } NewEvent = { ---@param signal Signal -- This is for IntelliSense Event = function(signal) while true do task.wait(5) signal:Fire(Random.new():NextInteger(1, math.huge)) end end }, }) local NewProperty = workspace.NewProperty NewProperty = workspace:NewMethod() local NewConnection = workspace.NewEvent:Connect(function(randomInteger) print(tostring(randomInteger)) end)   "},{"title":"WaitForProperty​","type":1,"pageTitle":"WrappedInstance","url":"api/WrappedInstance#WaitForProperty","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; WrappedInstance:WaitForProperty( propertyName: string, timeOut?: number ) → any Basically like &lt;Instance&gt;:WaitForChild() but for properties This is useful when you want to add a method that returns a property but the property isn't there yet You can see this function being used in the Add function example above. "},{"title":"Basic Guide","type":0,"sectionRef":"#","url":"docs/Basic Guide","content":"Basic Guide Lets say you wanna add a custom property, method and event to the workspace. First we need to wrap the workspace. --[[ we can add IntelliSense by adding a @type comment on top of the variable (For people that use EmmyLua, Roblox LSP, sumneko's lua language server, etc.) ]] ---@type WrappedInstance | Workspace local workspace = WrapperService:new(workspace) Copy Now we have created a wrapped version of the workspace, we can add properties to them! workspace:Add({ NewString = { Property = &quot;This is a new property!&quot; }, GetNewString = { Method = function() return workspace.NewString end }, onNewStringChanged = { ---@param signal Signal -- This is for IntelliSense Event = function(signal) repeat task.wait() until signal.__callbacks[1] -- Waits until a callback is connected --[[ We have to use :WaitForProperty because this function may get called first before NewString is added ]] local currentValue = workspace:WaitForProperty(&quot;NewString&quot;) while true do task.wait() if WrapperService.isWrapped(workspace) and workspace:WaitForProperty(&quot;NewString&quot;) ~= currentValue then signal:Fire(workspace:WaitForProperty(&quot;NewString&quot;), currentValue) currentValue = workspace:WaitForProperty(&quot;NewString&quot;) elseif not WrapperService.isWrapped(workspace) then --[[ will break the loop when the wrapped version of workspace is destroyed/cleaned ]] break end end end }, }) Copy Now we can use them as normal properties! local Connection = workspace.onNewStringChanged:Connect(function(newValue, lastValue) print(newValue, lastValue) -- Changed This is a new property! end) task.wait(1) workspace.NewString = &quot;Changed&quot; local newString = workspace:GetNewString() print(newString) -- Changed Copy There is still more to explore, go to the API Docs for more information!","keywords":""},{"title":"Installation","type":0,"sectionRef":"#","url":"docs/intro","content":"Installation The installation guide is found on the github releases page.","keywords":""}]