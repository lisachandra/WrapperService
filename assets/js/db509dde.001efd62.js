"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[543],{63590:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return p},toc:function(){return l},default:function(){return d}});var a=t(87462),r=t(63366),o=(t(67294),t(3905)),i=["components"],s={},c="Basic Guide",p={unversionedId:"Basic Guide",id:"Basic Guide",isDocsHomePage:!1,title:"Basic Guide",description:"Lets say you wanna add a custom property, method and event to the workspace.",source:"@site/docs/Basic Guide.md",sourceDirName:".",slug:"/Basic Guide",permalink:"/WrapperService/docs/Basic Guide",editUrl:"https://github.com/zxibs/WrapperService/edit/main/docs/Basic Guide.md",tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Installation",permalink:"/WrapperService/docs/intro"}},l=[],u={toc:l};function d(e){var n=e.components,t=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"basic-guide"},"Basic Guide"),(0,o.kt)("p",null,"Lets say you wanna add a custom property, method and event to the workspace.\nFirst we need to wrap the workspace."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"--[[\n    we can add IntelliSense by adding a @type comment on top of the variable \n    (For people that use EmmyLua, Roblox LSP, sumneko's lua language server, etc.)\n]]\n\nlocal workspace = WrapperService:new(workspace)\n")),(0,o.kt)("p",null,"Now we have created a wrapped version of the workspace,\nwe can add properties to them!"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},'workspace:Add({\n    NewString = {\n        Property = "This is a new property!"\n    },\n\n    GetNewString = {\n        Method = function(self)\n            return self.NewString\n        end\n    },\n\n    onNewStringChanged = {\n        Event = function(signal) -- This function will be the signal\'s fire handler.\n            repeat\n            task.wait()\n            until signal.__callbacks[1] -- Waits until a callback is connected\n\n            --[[\n                We have to use :WaitForProperty because \n                this function may get called first before NewString is added\n            ]]\n\n            local currentValue = workspace:WaitForProperty("NewString")\n\n            while true do\n                task.wait()\n\n                if WrapperService.isWrapped(workspace) and workspace:WaitForProperty("NewString") ~= currentValue then\n                    signal:Fire(workspace:WaitForProperty("NewString"), currentValue)\n                    currentValue = workspace:WaitForProperty("NewString")\n                elseif not WrapperService.isWrapped(workspace) then\n                    --[[\n                        will break the loop when the \n                        wrapped version of workspace is destroyed/cleaned\n                    ]]\n\n                    break \n                end\n            end\n        end\n    },\n})\n')),(0,o.kt)("p",null,"Now we can use them as normal properties!"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},'local Connection = workspace.onNewStringChanged:Connect(function(newValue, lastValue)\n    print(newValue, lastValue) -- Changed This is a new property!\nend)\n\ntask.wait(1)\n\nworkspace.NewString = "Changed"\n\nlocal newString = workspace:GetNewString()\nprint(newString) -- Changed\n')),(0,o.kt)("p",null,"There is still more to explore, go to the API Docs for more information!"))}d.isMDXComponent=!0}}]);